<h1 id="why-requests-instead-of-x-">Why Requests Instead of X?</h1>
<p>This is a quick look at why you should use Requests instead of another
solution. Keep in mind though that these are my point of view, and they may not
be issues for you.</p>
<p>As always with software, you should choose what you think is best.</p>
<h2 id="why-should-i-use-requests-">Why should I use Requests?</h2>
<ol>
<li><p><strong>Designed for maximum compatibility</strong></p>
<p>The realities of working with widely deployable software mean that awesome
PHP features aren&#39;t always available. PHP 5.3, cURL, OpenSSL and more are not
necessarily going to be available on every system. While you&#39;re welcome to
require PHP 5.3, 5.4 or even 5.5, it&#39;s not our job to force you to use those.</p>
<p>(The WordPress project estimates <a href="https://wordpress.org/about/stats/">about 60%</a> of hosts are running
PHP 5.2, so this is a serious issue for developers working on large
deployable projects.)</p>
<p>Don&#39;t worry though, Requests will automatically use better features where
possible, giving you an extra speed boost with cURL.</p>
</li>
<li><p><strong>Simple API</strong></p>
<p>Requests&#39; API is designed to be able to be learnt in 10 minutes. Everything
from basic requests all the way up to advanced usage involving custom SSL
certificates and stored cookies is handled by a simple API.</p>
<p>Other HTTP libraries optimize for the library developer&#39;s time; <strong>Requests
optimizes for your time</strong>.</p>
</li>
<li><p><strong>Thoroughly tested</strong></p>
<p>Requests is <a href="https://travis-ci.org/rmccue/Requests">continuously integrated with Travis</a> and test coverage
is <a href="https://coveralls.io/r/rmccue/Requests">constantly monitored with Coveralls</a> to give you confidence in
the library. We aim for test coverage <strong>over 90%</strong> at all times, and new
features require new tests to go along with them. This ensures that you can
be confident in the quality of the code, as well as being able to update to
the latest version of Requests without worrying about compatibility.</p>
</li>
<li><p><strong>Secure by default</strong></p>
<p>Unlike other HTTP libraries, Requests is secure by default. Requests is the
<strong>first and currently only</strong> standalone HTTP library to
<strong><a href="https://github.com/rmccue/Requests/blob/master/library/Requests/SSL.php">fully verify</a> all HTTPS requests</strong> even without cURL. We
also bundle the latest root certificate authorities to ensure that your
secure requests are actually secure.</p>
<p>(Of note is that WordPress as of version 3.7 also supports full checking of
the certificates, thanks to <a href="https://core.trac.wordpress.org/ticket/25007">evangelism efforts on our behalf</a>.
Together, we are the only HTTP libraries in PHP to fully verify certificates
to the same level as browsers.)</p>
</li>
<li><p><strong>Extensible from the core</strong></p>
<p>If you need low-level access to Requests&#39; internals, simply plug your
callbacks in via the built-in <a href="hooks.md">hooking system</a> and mess around as much as
you want. Requests&#39; simple hooking system is so powerful that both
authentication handlers and cookie support is actually handled internally
with hooks.</p>
</li>
</ol>
<h2 id="why-shouldn-t-i-use-">Why shouldn&#39;t I use...</h2>
<p>Requests isn&#39;t the first or only HTTP library in PHP and it&#39;s important to
acknowledge the other solutions out there. Here&#39;s why you should use Requests
instead of something else, in our opinion.</p>
<h3 id="curl">cURL</h3>
<ol>
<li><p><strong>Not every host has cURL installed</strong></p>
<p>cURL is far from being ubiquitous, so you can&#39;t rely on it always being
available when distributing software. Anecdotal data collected from various
projects indicates that cURL is available on roughly 90% of hosts, but that
leaves 10% of hosts without it.</p>
</li>
<li><p><strong>cURL&#39;s interface sucks</strong></p>
<p>cURL&#39;s interface was designed for PHP 4, and hence uses resources with
horrible functions such as <code>curl_setopt()</code>. Combined with that, it uses 229
global constants, polluting the global namespace horribly.</p>
<p>Requests, on the other hand, exposes only a handful of classes to the
global namespace, most of which are for internal use. You can learn to use
the <code>Requests::request()</code> method and the <code>Requests_Response</code> object in the
space of 10 minutes and you already know how to use Requests.</p>
</li>
</ol>
<h3 id="guzzle">Guzzle</h3>
<ol>
<li><p><strong>Requires cURL and PHP 5.3+</strong></p>
<p>Guzzle is designed to be a client to fit a large number of installations, but
as a result of optimizing for Guzzle developer time, it uses cURL as an
underlying transport. As noted above, this is a majority of systems, but
far from all.</p>
<p>The same is true for PHP 5.3+. While we&#39;d all love to rely on PHP&#39;s newer
features, the fact is that a huge percentage of hosts are still running on
PHP 5.2. (The WordPress project estimates <a href="https://wordpress.org/about/stats/">about 60%</a> of hosts are
running PHP 5.2.)</p>
</li>
<li><p><strong>Not just a HTTP client</strong></p>
<p>Guzzle is not intended to just be a HTTP client, but rather to be a
full-featured REST client. Requests is just a HTTP client, intentionally. Our
development strategy is to act as a low-level library that REST clients can
easily be built on, not to provide the whole kitchen sink for you.</p>
<p>If you want to rapidly develop a web service client using a framework, Guzzle
will suit you perfectly. On the other hand, if you want a HTTP client without
all the rest, Requests is the way to go.</p>
</li>
</ol>
<h3 id="buzz">Buzz</h3>
<ol>
<li><p><strong>Requires PHP 5.3+</strong></p>
<p>As with Guzzle, while PHP 5.3+ is awesome, you can&#39;t always rely on it being
on a host. With widely distributable software, this is a huge problem.</p>
</li>
<li><p><strong>Not transport-transparent</strong></p>
<p>For making certain types of requests, such as multi-requests, you can&#39;t rely
on a high-level abstraction and instead have to use the low-level transports.
This really gains nothing (other than a fancy interface) over just using the
methods directly and means that you can&#39;t rely on features to be available.</p>
</li>
</ol>
<h3 id="fsockopen">fsockopen</h3>
<ol>
<li><p><strong>Very low-level</strong></p>
<p>fsockopen is used for working with sockets directly, so it only knows about
the transport layer (TCP in our case), not anything higher (i.e. HTTP on the
application layer). To be able to use fsockopen as a HTTP client, you need
to write all the HTTP code yourself, and once you&#39;re done, you&#39;ll end up
with something that is almost exactly like Requests.</p>
</li>
</ol>
<h3 id="pear-http_request2">PEAR HTTP_Request2</h3>
<ol>
<li><p><strong>Requires PEAR</strong></p>
<p>PEAR is (in theory) a great distribution system (with a less than wonderful
implementation), however it is not ubiquitous, as many hosts disable it to
save on space that most people aren&#39;t going to use anyway.</p>
<p>PEAR is also a pain for users. Users want to be able to download a zip of
your project without needing to install anything else from PEAR.</p>
<p>(If you really want though, Requests is available via PEAR. Check the README
to see how to grab it.)</p>
</li>
<li><p><strong>Depends on other PEAR utilities</strong></p>
<p>HTTP_Request2 requires Net_URL2 in order to function, locking you in to
using PEAR for your project.</p>
<p>Requests is entirely self-contained, and includes all the libraries it needs
(for example, Requests_IRI is based on ComplexPie_IRI by Geoffrey Sneddon).</p>
</li>
</ol>
<h3 id="pecl-httprequest">PECL HttpRequest</h3>
<ol>
<li><p><strong>Requires a PECL extension</strong></p>
<p>Similar to PEAR, users aren&#39;t big fans of installing extra libraries. Unlike
PEAR though, PECL extensions require compiling, which end users will be
unfamiliar with. In addition, on systems where users do not have full
control over PHP, they will be unable to install custom extensions.</p>
</li>
</ol>
<h3 id="zend-framework-s-zend-_http-_client">Zend Framework&#39;s Zend_Http_Client</h3>
<ol>
<li><p><strong>Requires other parts of the Zend Framework</strong></p>
<p>Similar to HTTP_Request2, Zend&#39;s client is not fully self-contained and
requires other components from the framework.</p>
</li>
</ol>
